using System;
using System.Collections.Generic;
using System.Net;
using System.Net.Sockets;
using System.Text;





//there are actually two namespaces in this .cs (VATestPlugin, VATestWinampPlugin... see way down below) and each contain a class that would be considered a, 'plugin' (since each contain the necessary static functions to be a VoiceAttack plugin)

namespace VATestPlugin
{

    public class VoiceAttackPlugin
    {

        //NOTE THAT THIS IS A SAMPLE CLASS AND IS NOT FOR ANY MEANINGFUL USE.
        //You will want to gut this completely if you plan on using it... lol

        public static string VA_DisplayName()
        {
            return "My VoiceAttack Plugin";  //this is what you will want displayed in dropdowns as well as in the log file to indicate the name of your plugin
        }

        public static string VA_DisplayInfo()
        {
            return "My VoiceAttack Plugin\r\n\r\nThis is just a sample.\r\n\r\n2014 VoiceAttack";  //this is just extended info that you might want to give to the user.  note that you should format this up properly.
        }

        public static Guid VA_Id()
        {
            return new Guid("{C16BEBA9-2003-4b7f-BFA2-55B7C607925B}");  //this id must be generated by YOU... it must be unique so VoiceAttack can identify and use the plugin
        }

        public static void VA_Init1(ref Dictionary<string, object> state, ref Dictionary<string, Int16?> conditions, ref Dictionary<string, string> textValues, ref Dictionary<string, object> extendedValues)
        {
            //this is where you can set up whatever session information that you want.  this will only be called once on voiceattack load, and it is called asynchronously.
            //the state parameter is a local copy of the state held on to by VoiceAttack.  In this case, the state will be a dictionary with zero items.  You can add as many items to hold on to as you want.
            //the conditions and textValues will also be empty.  You can add whatever you want to those lists and VoiceAttack will copy the values into its own lists

            conditions.Add("initializedCondition1", 1);  //add some meaningless example conditions
            conditions.Add("initializedCondition2", 2);

            textValues.Add("initializedText1", "This is 1");  //add some meaningless example text values
            textValues.Add("initializedText2", "This is 2");

            state.Add("new state value", 369);  //add whatever private state information you want to maintain
            state.Add("second new state value", "hello");
        }

        public static void VA_Exit1(ref Dictionary<string, object> state)
        {
            //this function gets called when VoiceAttack is closing (normally).  You would put your cleanup code in here, but be aware that your code must be robust enough to not absolutely depend on this function being called
            if (state.ContainsKey("myStateValue"))
            {
                //do some kind of file cleanup or whatever at this point
            }
        }

        public static void VA_Invoke1(String context, ref Dictionary<string, object> state, ref Dictionary<string, Int16?> conditions, ref Dictionary<string, string> textValues, ref Dictionary<string, object> extendedValues)
        {
            
            string strMsg = "";
            if (textValues.ContainsKey("Home_Location")) //was the text value passed in?
            {
                if (textValues["Home_Location"] == null) //if the value is null, set the value to, 'Vault 111'
                    strMsg = "Vault 111";
                else

                    strMsg = textValues["Home_Location"];
            }

            if (textValues.ContainsKey("FT_Location")) //was the text value passed in?
            {
                if (textValues["FT_Location"] == null) //if the value is null, set the value to, 'Vault 111'
                    strMsg = "Vault 111";
                else

                    strMsg = textValues["FT_Location"];
            }

            String sndClient = SendMsg(IPAddress.Parse("127.0.0.1"), 8089, strMsg);



        }

        static public string SendMsg(IPAddress ipAddress, int thePort, string themessage)
        {
            byte[] bytes = new byte[1024];
            string result = "";
            // Connect to a remote device.
            try
            {
                // Establish the remote endpoint for the socket.
                // This example uses port 11000 on the local computer.
                IPHostEntry ipHostInfo = Dns.GetHostEntry(Dns.GetHostName());
                IPEndPoint remoteEP = new IPEndPoint(ipAddress, thePort);

                // Create a TCP/IP  socket.
                Socket sender = new Socket(ipAddress.AddressFamily, SocketType.Stream, ProtocolType.Tcp);

                // Connect the socket to the remote endpoint. Catch any errors.
                try
                {
                    sender.Connect(remoteEP);


                    // Encode the data string into a byte array.
                    byte[] msg = Encoding.ASCII.GetBytes(themessage);

                    // Send the data through the socket.
                    int bytesSent = sender.Send(msg);

                    // Receive the response from the remote device.
                    int bytesRec = sender.Receive(bytes);
                    result = String.Format("Echoed test = {0}", Encoding.ASCII.GetString(bytes, 0, bytesRec));
                    return result;
                    // Release the socket.
                    sender.Shutdown(SocketShutdown.Both);
                    sender.Close();

                }
                catch (ArgumentNullException ane)
                {
                    Console.WriteLine("ArgumentNullException : {0}", ane.ToString());
                    result = "Erro1";
                    return result;
                }
                catch (SocketException se)
                {
                    Console.WriteLine("SocketException : {0}", se.ToString());
                    result = "Not Connected";
                    return result;
                }
                catch (Exception e)
                {
                    Console.WriteLine("Unexpected exception : {0}", e.ToString());
                    result = "Erro3";
                    return result;
                }

            }
            catch (Exception e)
            {
                Console.WriteLine(e.ToString());
                result = "Erro4";
                return result;
            }
            
        }
     


    }
    
}


//this is the second namespace.  both classes could have been in the same namespace.  this is just an example.  
namespace VATestWinampPlugin
{
    //this is a very basic plugin created very quickly (maybe 20 minutes, including the profile).  Note that this class depends on the WinampLib.cs file also located in this project.

    //also note that you'll need a running instance of winamp to actually see anything happen... pick a good song and play it while you are issuing voice commands

    public class VoiceAttackSampleWinampPlugin
    {
        public static string VA_DisplayName()
        {
            return "VoiceAttack Simple Winamp Plugin";  //a name to distinguish my plugin from others
        }

        public static Guid VA_Id()
        {
            return new Guid("{99845215-1FF8-4e36-A370-87178D01C7B4}");   //note this is a new guid for this plugin
        }

        public static string VA_DisplayInfo()
        {
            return "VoiceAttack Winamp Sample Plugin\r\n\r\nThis is just a sample to show how VoiceAttack can interact with Winamp.\r\n\r\n2014 VoiceAttack";  //this is just extended info that you might want to give to the user.  note that you should format this up properly.
        }

        public static void VA_Init1(ref Dictionary<string, object> state, ref Dictionary<string, Int16?> conditions, ref Dictionary<string, string> textValues, ref Dictionary<string, object> extendedValues)
        {
            //not needing to initialize anything here this time
        }

        public static void VA_Exit1(ref Dictionary<string, object> state)
        {
            //no need to do anything on exit with this implementation
        }

        public static void VA_Invoke1(String context, ref Dictionary<string, object> state, ref Dictionary<string, Int16?> conditions, ref Dictionary<string, string> textValues, ref Dictionary<string, object> extendedValues)
        {
            //i was going to convert over some old delphi code I had written that does pretty much all this is doing, but I found a winamp library in c# out on code project instead.  saved a BUNCH of time :)


            //NOTE : In this example we could have more easily set the context value, but the illustration is in showing how values can be passed thru conditions and text values

            Int16? iVal;  //note that this is a nullable int16... that means that the value can be int16 or null

            if (conditions.TryGetValue("vaSampleWinampCommand", out iVal))  //see if the vaSampleWinampeCommand condition exists and has a value.  note that in the included Winamp profile, vaSampleWinampeCommand is being set to a certain value, depending on the command.  if vaSampleWinampeCommand is set to 1, this means, 'play'.
            {                                                               //2 means, 'pause', 3 means, 'stop' and so on.
                switch (iVal) //based on what is passed in, we just call out to the winamp library to make things happen.
                {
                    case 1:
                        WinampFrontEndLib.WinampLib.Play();
                        break;
                    case 2:
                        WinampFrontEndLib.WinampLib.Pause();
                        break;
                    case 3:
                        WinampFrontEndLib.WinampLib.Stop();
                        break;
                    case 4:
                        WinampFrontEndLib.WinampLib.VolumeUp();
                        break;
                    case 5:
                        WinampFrontEndLib.WinampLib.VolumeDown();
                        break;
                    case 6:  //set the volume to a value from 0 to 255
                        Int16? iVolume;
                        if (conditions.TryGetValue("vaSampleWinampVolume", out iVolume))
                        {
                            if (iVolume.HasValue)
                                WinampFrontEndLib.WinampLib.SetVolume(iVolume.Value);  //iVolume can be null at this point
                        }
                        break;
                    case 7:
                        WinampFrontEndLib.WinampLib.NextTrack();
                        break;
                    case 8:
                        WinampFrontEndLib.WinampLib.PrevTrack();
                        break;
                    case 9:  //this gets the the current song title and sends it back to VA in a text value.  in the included winamp profile, you will notice that the title that is sent back is read using text-to-speech
                        String strTitle = WinampFrontEndLib.WinampLib.GetCurrentSongTitle();
                        if (textValues.ContainsKey("vaSampleWinampTextTitle"))
                            textValues["vaSampleWinampTextTitle"] = strTitle;
                        else
                            textValues.Add("vaSampleWinampTextTitle", strTitle);
                        break;
                    default:  //the catch-all for this is to just bail out (undefined or null or whatever)
                        break;
                }
            }
        }
    }
}


