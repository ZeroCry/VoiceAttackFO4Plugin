using System;
using System.Collections.Generic;
using System.Net;
using System.Net.Sockets;
using System.Text;





//there are actually two namespaces in this .cs (VATestPlugin, VATestWinampPlugin... see way down below) and each contain a class that would be considered a, 'plugin' (since each contain the necessary static functions to be a VoiceAttack plugin)

namespace VoiceAttackFO4Plugin
{

    public class VoiceAttackPlugin
    {

        

        public static string VA_DisplayName()
        {
            return "My VoiceAttack Plugin";  //this is what you will want displayed in dropdowns as well as in the log file to indicate the name of your plugin
        }

        public static string VA_DisplayInfo()
        {
            return "My VoiceAttack Plugin\r\n\r\nThis is just a sample.\r\n\r\n2014 VoiceAttack";  //this is just extended info that you might want to give to the user.  note that you should format this up properly.
        }

        public static Guid VA_Id()
        {
            return new Guid("{C16BEBA9-2003-4b7f-BFA2-55B7C607925B}");  //this id must be generated by YOU... it must be unique so VoiceAttack can identify and use the plugin
        }

        public static void VA_Init1(ref Dictionary<string, object> state, ref Dictionary<string, Int16?> conditions, ref Dictionary<string, string> textValues, ref Dictionary<string, object> extendedValues)
        {
            //this is where you can set up whatever session information that you want.  this will only be called once on voiceattack load, and it is called asynchronously.
            //the state parameter is a local copy of the state held on to by VoiceAttack.  In this case, the state will be a dictionary with zero items.  You can add as many items to hold on to as you want.
            //the conditions and textValues will also be empty.  You can add whatever you want to those lists and VoiceAttack will copy the values into its own lists

            conditions.Add("initializedCondition1", 1);  //add some meaningless example conditions
            conditions.Add("initializedCondition2", 2);

            textValues.Add("initializedText1", "This is 1");  //add some meaningless example text values
            textValues.Add("initializedText2", "This is 2");

            state.Add("new state value", 369);  //add whatever private state information you want to maintain
            state.Add("second new state value", "hello");
        }

        public static void VA_Exit1(ref Dictionary<string, object> state)
        {
            //this function gets called when VoiceAttack is closing (normally).  You would put your cleanup code in here, but be aware that your code must be robust enough to not absolutely depend on this function being called
            if (state.ContainsKey("myStateValue"))
            {
                //do some kind of file cleanup or whatever at this point
            }
        }

        public static void VA_Invoke1(String context, ref Dictionary<string, object> state, ref Dictionary<string, Int16?> conditions, ref Dictionary<string, string> textValues, ref Dictionary<string, object> extendedValues)
        {
            //This function is where you will do all of your work.  When VoiceAttack encounters an, 'Execute External Plugin Function' action, the plugin indicated will be called.

            //What you are getting in this function as parameters :

            //context - a string that can be anything you want it to be.  this is passed in from the command action.  this was added to allow you to just pass a value into the plugin in a simple fashion (without having to set conditions/text values beforehand).  Convert the string to whatever type you need to.

            //three dictionaries which are all local copies :
            //state - all values from the state maintained by VoiceAttack for this plugin.  the state allows you to maintain kind of a, 'session' within VoiceAttack.  this value is not persisted to disk and will be erased on restart. other plugins do not have access to this state (private to the plugin)
            //conditions - the conditions that were specified in the, 'Execute External' command action.
            //textValues - the text values that were specified in the, 'Execute External' command action.
            //(you also get, 'extendedValues', but, that will be null because it is for future use)

            //the condition and text value dictionaries can be manipulated as follows :
            //items can be updated
            //items can be added to the dictionary
            //to indicate to VoiceAttack that you want to remove an item from the each dictionary, set its value to null (a process is already in place to remove items that are null for cleanup purposes, so, we can just use that)
            //any updated values will be reflected back to existing VoiceAttack internal values.
            //any added values will be added to the VoiceAttack internal values.

            //the state dictionary is the complete state.  you can manipulate it however you want, the whole thing will be copied back and replace what VoiceAttack is holding on to

            //if the, 'Execute External Plugin Function' command action has the, 'wait for return' flag set, VoiceAttack will wait until this function completes so that you may check condition values and
            //have VoiceAttack react accordingly.  otherwise, VoiceAttack fires and forgets and doesn't hang out for extra processing.


            //below is just some sample code showing how to work with dicitionaries...  in case you're not familiar with them.  just wouldn't feel complete unless i included it for some reason :)

            //here we test to see if the dictionary contains a certain key.  checking for the key first is important to avoid errors.  you can do this when setting a value and, 'TryGetValue' when you are retrieving values
            string strMsg = "";
            if (textValues.ContainsKey("Home_Location")) //was the text value passed in?
            {
                if (textValues["Home_Location"] == null) //if the value is null, set the value to, 'Vault 111'
                    strMsg = "Vault 111";
                else

                    strMsg = textValues["Home_Location"];
            }

            if (textValues.ContainsKey("FT_Location")) //was the text value passed in?
            {
                if (textValues["FT_Location"] == null) //if the value is null, set the value to, 'Vault 111'
                    strMsg = "Vault 111";
                else

                    strMsg = textValues["FT_Location"];
            }

            String sndClient = SendMsg(IPAddress.Parse("127.0.0.1"), 8089, strMsg);



        }

        static public string SendMsg(IPAddress ipAddress, int thePort, string themessage)
        {
            byte[] bytes = new byte[1024];
            string result = "";
            // Connect to a remote device.
            try
            {
                // Establish the remote endpoint for the socket.
                // This example uses port 11000 on the local computer.
                IPHostEntry ipHostInfo = Dns.GetHostEntry(Dns.GetHostName());
                IPEndPoint remoteEP = new IPEndPoint(ipAddress, thePort);

                // Create a TCP/IP  socket.
                Socket sender = new Socket(ipAddress.AddressFamily, SocketType.Stream, ProtocolType.Tcp);

                // Connect the socket to the remote endpoint. Catch any errors.
                try
                {
                    sender.Connect(remoteEP);


                    // Encode the data string into a byte array.
                    byte[] msg = Encoding.ASCII.GetBytes(themessage);

                    // Send the data through the socket.
                    int bytesSent = sender.Send(msg);

                    // Receive the response from the remote device.
                    int bytesRec = sender.Receive(bytes);
                    result = String.Format("Echoed test = {0}", Encoding.ASCII.GetString(bytes, 0, bytesRec));
                    return result;
                    // Release the socket.
                    sender.Shutdown(SocketShutdown.Both);
                    sender.Close();

                }
                catch (ArgumentNullException ane)
                {
                    Console.WriteLine("ArgumentNullException : {0}", ane.ToString());
                    result = "Erro1";
                    return result;
                }
                catch (SocketException se)
                {
                    Console.WriteLine("SocketException : {0}", se.ToString());
                    result = "Not Connected";
                    return result;
                }
                catch (Exception e)
                {
                    Console.WriteLine("Unexpected exception : {0}", e.ToString());
                    result = "Erro3";
                    return result;
                }

            }
            catch (Exception e)
            {
                Console.WriteLine(e.ToString());
                result = "Erro4";
                return result;
            }

        }



    }

}




